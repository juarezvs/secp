
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `PunchEvent` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model PunchEvent
 * 
 */
export type PunchEventModel = runtime.Types.Result.DefaultSelection<Prisma.$PunchEventPayload>

export type AggregatePunchEvent = {
  _count: PunchEventCountAggregateOutputType | null
  _min: PunchEventMinAggregateOutputType | null
  _max: PunchEventMaxAggregateOutputType | null
}

export type PunchEventMinAggregateOutputType = {
  id: string | null
  tenantId: string | null
  employeeId: string | null
  occurredAt: Date | null
  kind: $Enums.PunchKind | null
  source: $Enums.PunchSource | null
  deviceId: string | null
  integrityHash: string | null
  createdAt: Date | null
}

export type PunchEventMaxAggregateOutputType = {
  id: string | null
  tenantId: string | null
  employeeId: string | null
  occurredAt: Date | null
  kind: $Enums.PunchKind | null
  source: $Enums.PunchSource | null
  deviceId: string | null
  integrityHash: string | null
  createdAt: Date | null
}

export type PunchEventCountAggregateOutputType = {
  id: number
  tenantId: number
  employeeId: number
  occurredAt: number
  kind: number
  source: number
  deviceId: number
  rawPayload: number
  integrityHash: number
  createdAt: number
  _all: number
}


export type PunchEventMinAggregateInputType = {
  id?: true
  tenantId?: true
  employeeId?: true
  occurredAt?: true
  kind?: true
  source?: true
  deviceId?: true
  integrityHash?: true
  createdAt?: true
}

export type PunchEventMaxAggregateInputType = {
  id?: true
  tenantId?: true
  employeeId?: true
  occurredAt?: true
  kind?: true
  source?: true
  deviceId?: true
  integrityHash?: true
  createdAt?: true
}

export type PunchEventCountAggregateInputType = {
  id?: true
  tenantId?: true
  employeeId?: true
  occurredAt?: true
  kind?: true
  source?: true
  deviceId?: true
  rawPayload?: true
  integrityHash?: true
  createdAt?: true
  _all?: true
}

export type PunchEventAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which PunchEvent to aggregate.
   */
  where?: Prisma.PunchEventWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PunchEvents to fetch.
   */
  orderBy?: Prisma.PunchEventOrderByWithRelationInput | Prisma.PunchEventOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.PunchEventWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PunchEvents from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PunchEvents.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned PunchEvents
  **/
  _count?: true | PunchEventCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: PunchEventMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: PunchEventMaxAggregateInputType
}

export type GetPunchEventAggregateType<T extends PunchEventAggregateArgs> = {
      [P in keyof T & keyof AggregatePunchEvent]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregatePunchEvent[P]>
    : Prisma.GetScalarType<T[P], AggregatePunchEvent[P]>
}




export type PunchEventGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.PunchEventWhereInput
  orderBy?: Prisma.PunchEventOrderByWithAggregationInput | Prisma.PunchEventOrderByWithAggregationInput[]
  by: Prisma.PunchEventScalarFieldEnum[] | Prisma.PunchEventScalarFieldEnum
  having?: Prisma.PunchEventScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: PunchEventCountAggregateInputType | true
  _min?: PunchEventMinAggregateInputType
  _max?: PunchEventMaxAggregateInputType
}

export type PunchEventGroupByOutputType = {
  id: string
  tenantId: string
  employeeId: string
  occurredAt: Date
  kind: $Enums.PunchKind
  source: $Enums.PunchSource
  deviceId: string | null
  rawPayload: runtime.JsonValue | null
  integrityHash: string | null
  createdAt: Date
  _count: PunchEventCountAggregateOutputType | null
  _min: PunchEventMinAggregateOutputType | null
  _max: PunchEventMaxAggregateOutputType | null
}

type GetPunchEventGroupByPayload<T extends PunchEventGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<PunchEventGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof PunchEventGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], PunchEventGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], PunchEventGroupByOutputType[P]>
      }
    >
  >



export type PunchEventWhereInput = {
  AND?: Prisma.PunchEventWhereInput | Prisma.PunchEventWhereInput[]
  OR?: Prisma.PunchEventWhereInput[]
  NOT?: Prisma.PunchEventWhereInput | Prisma.PunchEventWhereInput[]
  id?: Prisma.StringFilter<"PunchEvent"> | string
  tenantId?: Prisma.StringFilter<"PunchEvent"> | string
  employeeId?: Prisma.StringFilter<"PunchEvent"> | string
  occurredAt?: Prisma.DateTimeFilter<"PunchEvent"> | Date | string
  kind?: Prisma.EnumPunchKindFilter<"PunchEvent"> | $Enums.PunchKind
  source?: Prisma.EnumPunchSourceFilter<"PunchEvent"> | $Enums.PunchSource
  deviceId?: Prisma.StringNullableFilter<"PunchEvent"> | string | null
  rawPayload?: Prisma.JsonNullableFilter<"PunchEvent">
  integrityHash?: Prisma.StringNullableFilter<"PunchEvent"> | string | null
  createdAt?: Prisma.DateTimeFilter<"PunchEvent"> | Date | string
  tenant?: Prisma.XOR<Prisma.TenantScalarRelationFilter, Prisma.TenantWhereInput>
  employee?: Prisma.XOR<Prisma.EmployeeScalarRelationFilter, Prisma.EmployeeWhereInput>
  device?: Prisma.XOR<Prisma.BiometricDeviceNullableScalarRelationFilter, Prisma.BiometricDeviceWhereInput> | null
}

export type PunchEventOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  employeeId?: Prisma.SortOrder
  occurredAt?: Prisma.SortOrder
  kind?: Prisma.SortOrder
  source?: Prisma.SortOrder
  deviceId?: Prisma.SortOrderInput | Prisma.SortOrder
  rawPayload?: Prisma.SortOrderInput | Prisma.SortOrder
  integrityHash?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  tenant?: Prisma.TenantOrderByWithRelationInput
  employee?: Prisma.EmployeeOrderByWithRelationInput
  device?: Prisma.BiometricDeviceOrderByWithRelationInput
}

export type PunchEventWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.PunchEventWhereInput | Prisma.PunchEventWhereInput[]
  OR?: Prisma.PunchEventWhereInput[]
  NOT?: Prisma.PunchEventWhereInput | Prisma.PunchEventWhereInput[]
  tenantId?: Prisma.StringFilter<"PunchEvent"> | string
  employeeId?: Prisma.StringFilter<"PunchEvent"> | string
  occurredAt?: Prisma.DateTimeFilter<"PunchEvent"> | Date | string
  kind?: Prisma.EnumPunchKindFilter<"PunchEvent"> | $Enums.PunchKind
  source?: Prisma.EnumPunchSourceFilter<"PunchEvent"> | $Enums.PunchSource
  deviceId?: Prisma.StringNullableFilter<"PunchEvent"> | string | null
  rawPayload?: Prisma.JsonNullableFilter<"PunchEvent">
  integrityHash?: Prisma.StringNullableFilter<"PunchEvent"> | string | null
  createdAt?: Prisma.DateTimeFilter<"PunchEvent"> | Date | string
  tenant?: Prisma.XOR<Prisma.TenantScalarRelationFilter, Prisma.TenantWhereInput>
  employee?: Prisma.XOR<Prisma.EmployeeScalarRelationFilter, Prisma.EmployeeWhereInput>
  device?: Prisma.XOR<Prisma.BiometricDeviceNullableScalarRelationFilter, Prisma.BiometricDeviceWhereInput> | null
}, "id">

export type PunchEventOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  employeeId?: Prisma.SortOrder
  occurredAt?: Prisma.SortOrder
  kind?: Prisma.SortOrder
  source?: Prisma.SortOrder
  deviceId?: Prisma.SortOrderInput | Prisma.SortOrder
  rawPayload?: Prisma.SortOrderInput | Prisma.SortOrder
  integrityHash?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.PunchEventCountOrderByAggregateInput
  _max?: Prisma.PunchEventMaxOrderByAggregateInput
  _min?: Prisma.PunchEventMinOrderByAggregateInput
}

export type PunchEventScalarWhereWithAggregatesInput = {
  AND?: Prisma.PunchEventScalarWhereWithAggregatesInput | Prisma.PunchEventScalarWhereWithAggregatesInput[]
  OR?: Prisma.PunchEventScalarWhereWithAggregatesInput[]
  NOT?: Prisma.PunchEventScalarWhereWithAggregatesInput | Prisma.PunchEventScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"PunchEvent"> | string
  tenantId?: Prisma.StringWithAggregatesFilter<"PunchEvent"> | string
  employeeId?: Prisma.StringWithAggregatesFilter<"PunchEvent"> | string
  occurredAt?: Prisma.DateTimeWithAggregatesFilter<"PunchEvent"> | Date | string
  kind?: Prisma.EnumPunchKindWithAggregatesFilter<"PunchEvent"> | $Enums.PunchKind
  source?: Prisma.EnumPunchSourceWithAggregatesFilter<"PunchEvent"> | $Enums.PunchSource
  deviceId?: Prisma.StringNullableWithAggregatesFilter<"PunchEvent"> | string | null
  rawPayload?: Prisma.JsonNullableWithAggregatesFilter<"PunchEvent">
  integrityHash?: Prisma.StringNullableWithAggregatesFilter<"PunchEvent"> | string | null
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"PunchEvent"> | Date | string
}

export type PunchEventCreateInput = {
  id?: string
  occurredAt: Date | string
  kind: $Enums.PunchKind
  source: $Enums.PunchSource
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: string | null
  createdAt?: Date | string
  tenant: Prisma.TenantCreateNestedOneWithoutPunchEventsInput
  employee: Prisma.EmployeeCreateNestedOneWithoutPunchesInput
  device?: Prisma.BiometricDeviceCreateNestedOneWithoutPunchesInput
}

export type PunchEventUncheckedCreateInput = {
  id?: string
  tenantId: string
  employeeId: string
  occurredAt: Date | string
  kind: $Enums.PunchKind
  source: $Enums.PunchSource
  deviceId?: string | null
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: string | null
  createdAt?: Date | string
}

export type PunchEventUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  occurredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  kind?: Prisma.EnumPunchKindFieldUpdateOperationsInput | $Enums.PunchKind
  source?: Prisma.EnumPunchSourceFieldUpdateOperationsInput | $Enums.PunchSource
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  tenant?: Prisma.TenantUpdateOneRequiredWithoutPunchEventsNestedInput
  employee?: Prisma.EmployeeUpdateOneRequiredWithoutPunchesNestedInput
  device?: Prisma.BiometricDeviceUpdateOneWithoutPunchesNestedInput
}

export type PunchEventUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  employeeId?: Prisma.StringFieldUpdateOperationsInput | string
  occurredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  kind?: Prisma.EnumPunchKindFieldUpdateOperationsInput | $Enums.PunchKind
  source?: Prisma.EnumPunchSourceFieldUpdateOperationsInput | $Enums.PunchSource
  deviceId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PunchEventCreateManyInput = {
  id?: string
  tenantId: string
  employeeId: string
  occurredAt: Date | string
  kind: $Enums.PunchKind
  source: $Enums.PunchSource
  deviceId?: string | null
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: string | null
  createdAt?: Date | string
}

export type PunchEventUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  occurredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  kind?: Prisma.EnumPunchKindFieldUpdateOperationsInput | $Enums.PunchKind
  source?: Prisma.EnumPunchSourceFieldUpdateOperationsInput | $Enums.PunchSource
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PunchEventUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  employeeId?: Prisma.StringFieldUpdateOperationsInput | string
  occurredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  kind?: Prisma.EnumPunchKindFieldUpdateOperationsInput | $Enums.PunchKind
  source?: Prisma.EnumPunchSourceFieldUpdateOperationsInput | $Enums.PunchSource
  deviceId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PunchEventListRelationFilter = {
  every?: Prisma.PunchEventWhereInput
  some?: Prisma.PunchEventWhereInput
  none?: Prisma.PunchEventWhereInput
}

export type PunchEventOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type PunchEventCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  employeeId?: Prisma.SortOrder
  occurredAt?: Prisma.SortOrder
  kind?: Prisma.SortOrder
  source?: Prisma.SortOrder
  deviceId?: Prisma.SortOrder
  rawPayload?: Prisma.SortOrder
  integrityHash?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type PunchEventMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  employeeId?: Prisma.SortOrder
  occurredAt?: Prisma.SortOrder
  kind?: Prisma.SortOrder
  source?: Prisma.SortOrder
  deviceId?: Prisma.SortOrder
  integrityHash?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type PunchEventMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  employeeId?: Prisma.SortOrder
  occurredAt?: Prisma.SortOrder
  kind?: Prisma.SortOrder
  source?: Prisma.SortOrder
  deviceId?: Prisma.SortOrder
  integrityHash?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type PunchEventCreateNestedManyWithoutTenantInput = {
  create?: Prisma.XOR<Prisma.PunchEventCreateWithoutTenantInput, Prisma.PunchEventUncheckedCreateWithoutTenantInput> | Prisma.PunchEventCreateWithoutTenantInput[] | Prisma.PunchEventUncheckedCreateWithoutTenantInput[]
  connectOrCreate?: Prisma.PunchEventCreateOrConnectWithoutTenantInput | Prisma.PunchEventCreateOrConnectWithoutTenantInput[]
  createMany?: Prisma.PunchEventCreateManyTenantInputEnvelope
  connect?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
}

export type PunchEventUncheckedCreateNestedManyWithoutTenantInput = {
  create?: Prisma.XOR<Prisma.PunchEventCreateWithoutTenantInput, Prisma.PunchEventUncheckedCreateWithoutTenantInput> | Prisma.PunchEventCreateWithoutTenantInput[] | Prisma.PunchEventUncheckedCreateWithoutTenantInput[]
  connectOrCreate?: Prisma.PunchEventCreateOrConnectWithoutTenantInput | Prisma.PunchEventCreateOrConnectWithoutTenantInput[]
  createMany?: Prisma.PunchEventCreateManyTenantInputEnvelope
  connect?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
}

export type PunchEventUpdateManyWithoutTenantNestedInput = {
  create?: Prisma.XOR<Prisma.PunchEventCreateWithoutTenantInput, Prisma.PunchEventUncheckedCreateWithoutTenantInput> | Prisma.PunchEventCreateWithoutTenantInput[] | Prisma.PunchEventUncheckedCreateWithoutTenantInput[]
  connectOrCreate?: Prisma.PunchEventCreateOrConnectWithoutTenantInput | Prisma.PunchEventCreateOrConnectWithoutTenantInput[]
  upsert?: Prisma.PunchEventUpsertWithWhereUniqueWithoutTenantInput | Prisma.PunchEventUpsertWithWhereUniqueWithoutTenantInput[]
  createMany?: Prisma.PunchEventCreateManyTenantInputEnvelope
  set?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  disconnect?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  delete?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  connect?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  update?: Prisma.PunchEventUpdateWithWhereUniqueWithoutTenantInput | Prisma.PunchEventUpdateWithWhereUniqueWithoutTenantInput[]
  updateMany?: Prisma.PunchEventUpdateManyWithWhereWithoutTenantInput | Prisma.PunchEventUpdateManyWithWhereWithoutTenantInput[]
  deleteMany?: Prisma.PunchEventScalarWhereInput | Prisma.PunchEventScalarWhereInput[]
}

export type PunchEventUncheckedUpdateManyWithoutTenantNestedInput = {
  create?: Prisma.XOR<Prisma.PunchEventCreateWithoutTenantInput, Prisma.PunchEventUncheckedCreateWithoutTenantInput> | Prisma.PunchEventCreateWithoutTenantInput[] | Prisma.PunchEventUncheckedCreateWithoutTenantInput[]
  connectOrCreate?: Prisma.PunchEventCreateOrConnectWithoutTenantInput | Prisma.PunchEventCreateOrConnectWithoutTenantInput[]
  upsert?: Prisma.PunchEventUpsertWithWhereUniqueWithoutTenantInput | Prisma.PunchEventUpsertWithWhereUniqueWithoutTenantInput[]
  createMany?: Prisma.PunchEventCreateManyTenantInputEnvelope
  set?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  disconnect?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  delete?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  connect?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  update?: Prisma.PunchEventUpdateWithWhereUniqueWithoutTenantInput | Prisma.PunchEventUpdateWithWhereUniqueWithoutTenantInput[]
  updateMany?: Prisma.PunchEventUpdateManyWithWhereWithoutTenantInput | Prisma.PunchEventUpdateManyWithWhereWithoutTenantInput[]
  deleteMany?: Prisma.PunchEventScalarWhereInput | Prisma.PunchEventScalarWhereInput[]
}

export type PunchEventCreateNestedManyWithoutEmployeeInput = {
  create?: Prisma.XOR<Prisma.PunchEventCreateWithoutEmployeeInput, Prisma.PunchEventUncheckedCreateWithoutEmployeeInput> | Prisma.PunchEventCreateWithoutEmployeeInput[] | Prisma.PunchEventUncheckedCreateWithoutEmployeeInput[]
  connectOrCreate?: Prisma.PunchEventCreateOrConnectWithoutEmployeeInput | Prisma.PunchEventCreateOrConnectWithoutEmployeeInput[]
  createMany?: Prisma.PunchEventCreateManyEmployeeInputEnvelope
  connect?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
}

export type PunchEventUncheckedCreateNestedManyWithoutEmployeeInput = {
  create?: Prisma.XOR<Prisma.PunchEventCreateWithoutEmployeeInput, Prisma.PunchEventUncheckedCreateWithoutEmployeeInput> | Prisma.PunchEventCreateWithoutEmployeeInput[] | Prisma.PunchEventUncheckedCreateWithoutEmployeeInput[]
  connectOrCreate?: Prisma.PunchEventCreateOrConnectWithoutEmployeeInput | Prisma.PunchEventCreateOrConnectWithoutEmployeeInput[]
  createMany?: Prisma.PunchEventCreateManyEmployeeInputEnvelope
  connect?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
}

export type PunchEventUpdateManyWithoutEmployeeNestedInput = {
  create?: Prisma.XOR<Prisma.PunchEventCreateWithoutEmployeeInput, Prisma.PunchEventUncheckedCreateWithoutEmployeeInput> | Prisma.PunchEventCreateWithoutEmployeeInput[] | Prisma.PunchEventUncheckedCreateWithoutEmployeeInput[]
  connectOrCreate?: Prisma.PunchEventCreateOrConnectWithoutEmployeeInput | Prisma.PunchEventCreateOrConnectWithoutEmployeeInput[]
  upsert?: Prisma.PunchEventUpsertWithWhereUniqueWithoutEmployeeInput | Prisma.PunchEventUpsertWithWhereUniqueWithoutEmployeeInput[]
  createMany?: Prisma.PunchEventCreateManyEmployeeInputEnvelope
  set?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  disconnect?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  delete?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  connect?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  update?: Prisma.PunchEventUpdateWithWhereUniqueWithoutEmployeeInput | Prisma.PunchEventUpdateWithWhereUniqueWithoutEmployeeInput[]
  updateMany?: Prisma.PunchEventUpdateManyWithWhereWithoutEmployeeInput | Prisma.PunchEventUpdateManyWithWhereWithoutEmployeeInput[]
  deleteMany?: Prisma.PunchEventScalarWhereInput | Prisma.PunchEventScalarWhereInput[]
}

export type PunchEventUncheckedUpdateManyWithoutEmployeeNestedInput = {
  create?: Prisma.XOR<Prisma.PunchEventCreateWithoutEmployeeInput, Prisma.PunchEventUncheckedCreateWithoutEmployeeInput> | Prisma.PunchEventCreateWithoutEmployeeInput[] | Prisma.PunchEventUncheckedCreateWithoutEmployeeInput[]
  connectOrCreate?: Prisma.PunchEventCreateOrConnectWithoutEmployeeInput | Prisma.PunchEventCreateOrConnectWithoutEmployeeInput[]
  upsert?: Prisma.PunchEventUpsertWithWhereUniqueWithoutEmployeeInput | Prisma.PunchEventUpsertWithWhereUniqueWithoutEmployeeInput[]
  createMany?: Prisma.PunchEventCreateManyEmployeeInputEnvelope
  set?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  disconnect?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  delete?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  connect?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  update?: Prisma.PunchEventUpdateWithWhereUniqueWithoutEmployeeInput | Prisma.PunchEventUpdateWithWhereUniqueWithoutEmployeeInput[]
  updateMany?: Prisma.PunchEventUpdateManyWithWhereWithoutEmployeeInput | Prisma.PunchEventUpdateManyWithWhereWithoutEmployeeInput[]
  deleteMany?: Prisma.PunchEventScalarWhereInput | Prisma.PunchEventScalarWhereInput[]
}

export type PunchEventCreateNestedManyWithoutDeviceInput = {
  create?: Prisma.XOR<Prisma.PunchEventCreateWithoutDeviceInput, Prisma.PunchEventUncheckedCreateWithoutDeviceInput> | Prisma.PunchEventCreateWithoutDeviceInput[] | Prisma.PunchEventUncheckedCreateWithoutDeviceInput[]
  connectOrCreate?: Prisma.PunchEventCreateOrConnectWithoutDeviceInput | Prisma.PunchEventCreateOrConnectWithoutDeviceInput[]
  createMany?: Prisma.PunchEventCreateManyDeviceInputEnvelope
  connect?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
}

export type PunchEventUncheckedCreateNestedManyWithoutDeviceInput = {
  create?: Prisma.XOR<Prisma.PunchEventCreateWithoutDeviceInput, Prisma.PunchEventUncheckedCreateWithoutDeviceInput> | Prisma.PunchEventCreateWithoutDeviceInput[] | Prisma.PunchEventUncheckedCreateWithoutDeviceInput[]
  connectOrCreate?: Prisma.PunchEventCreateOrConnectWithoutDeviceInput | Prisma.PunchEventCreateOrConnectWithoutDeviceInput[]
  createMany?: Prisma.PunchEventCreateManyDeviceInputEnvelope
  connect?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
}

export type PunchEventUpdateManyWithoutDeviceNestedInput = {
  create?: Prisma.XOR<Prisma.PunchEventCreateWithoutDeviceInput, Prisma.PunchEventUncheckedCreateWithoutDeviceInput> | Prisma.PunchEventCreateWithoutDeviceInput[] | Prisma.PunchEventUncheckedCreateWithoutDeviceInput[]
  connectOrCreate?: Prisma.PunchEventCreateOrConnectWithoutDeviceInput | Prisma.PunchEventCreateOrConnectWithoutDeviceInput[]
  upsert?: Prisma.PunchEventUpsertWithWhereUniqueWithoutDeviceInput | Prisma.PunchEventUpsertWithWhereUniqueWithoutDeviceInput[]
  createMany?: Prisma.PunchEventCreateManyDeviceInputEnvelope
  set?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  disconnect?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  delete?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  connect?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  update?: Prisma.PunchEventUpdateWithWhereUniqueWithoutDeviceInput | Prisma.PunchEventUpdateWithWhereUniqueWithoutDeviceInput[]
  updateMany?: Prisma.PunchEventUpdateManyWithWhereWithoutDeviceInput | Prisma.PunchEventUpdateManyWithWhereWithoutDeviceInput[]
  deleteMany?: Prisma.PunchEventScalarWhereInput | Prisma.PunchEventScalarWhereInput[]
}

export type PunchEventUncheckedUpdateManyWithoutDeviceNestedInput = {
  create?: Prisma.XOR<Prisma.PunchEventCreateWithoutDeviceInput, Prisma.PunchEventUncheckedCreateWithoutDeviceInput> | Prisma.PunchEventCreateWithoutDeviceInput[] | Prisma.PunchEventUncheckedCreateWithoutDeviceInput[]
  connectOrCreate?: Prisma.PunchEventCreateOrConnectWithoutDeviceInput | Prisma.PunchEventCreateOrConnectWithoutDeviceInput[]
  upsert?: Prisma.PunchEventUpsertWithWhereUniqueWithoutDeviceInput | Prisma.PunchEventUpsertWithWhereUniqueWithoutDeviceInput[]
  createMany?: Prisma.PunchEventCreateManyDeviceInputEnvelope
  set?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  disconnect?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  delete?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  connect?: Prisma.PunchEventWhereUniqueInput | Prisma.PunchEventWhereUniqueInput[]
  update?: Prisma.PunchEventUpdateWithWhereUniqueWithoutDeviceInput | Prisma.PunchEventUpdateWithWhereUniqueWithoutDeviceInput[]
  updateMany?: Prisma.PunchEventUpdateManyWithWhereWithoutDeviceInput | Prisma.PunchEventUpdateManyWithWhereWithoutDeviceInput[]
  deleteMany?: Prisma.PunchEventScalarWhereInput | Prisma.PunchEventScalarWhereInput[]
}

export type EnumPunchKindFieldUpdateOperationsInput = {
  set?: $Enums.PunchKind
}

export type EnumPunchSourceFieldUpdateOperationsInput = {
  set?: $Enums.PunchSource
}

export type PunchEventCreateWithoutTenantInput = {
  id?: string
  occurredAt: Date | string
  kind: $Enums.PunchKind
  source: $Enums.PunchSource
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: string | null
  createdAt?: Date | string
  employee: Prisma.EmployeeCreateNestedOneWithoutPunchesInput
  device?: Prisma.BiometricDeviceCreateNestedOneWithoutPunchesInput
}

export type PunchEventUncheckedCreateWithoutTenantInput = {
  id?: string
  employeeId: string
  occurredAt: Date | string
  kind: $Enums.PunchKind
  source: $Enums.PunchSource
  deviceId?: string | null
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: string | null
  createdAt?: Date | string
}

export type PunchEventCreateOrConnectWithoutTenantInput = {
  where: Prisma.PunchEventWhereUniqueInput
  create: Prisma.XOR<Prisma.PunchEventCreateWithoutTenantInput, Prisma.PunchEventUncheckedCreateWithoutTenantInput>
}

export type PunchEventCreateManyTenantInputEnvelope = {
  data: Prisma.PunchEventCreateManyTenantInput | Prisma.PunchEventCreateManyTenantInput[]
  skipDuplicates?: boolean
}

export type PunchEventUpsertWithWhereUniqueWithoutTenantInput = {
  where: Prisma.PunchEventWhereUniqueInput
  update: Prisma.XOR<Prisma.PunchEventUpdateWithoutTenantInput, Prisma.PunchEventUncheckedUpdateWithoutTenantInput>
  create: Prisma.XOR<Prisma.PunchEventCreateWithoutTenantInput, Prisma.PunchEventUncheckedCreateWithoutTenantInput>
}

export type PunchEventUpdateWithWhereUniqueWithoutTenantInput = {
  where: Prisma.PunchEventWhereUniqueInput
  data: Prisma.XOR<Prisma.PunchEventUpdateWithoutTenantInput, Prisma.PunchEventUncheckedUpdateWithoutTenantInput>
}

export type PunchEventUpdateManyWithWhereWithoutTenantInput = {
  where: Prisma.PunchEventScalarWhereInput
  data: Prisma.XOR<Prisma.PunchEventUpdateManyMutationInput, Prisma.PunchEventUncheckedUpdateManyWithoutTenantInput>
}

export type PunchEventScalarWhereInput = {
  AND?: Prisma.PunchEventScalarWhereInput | Prisma.PunchEventScalarWhereInput[]
  OR?: Prisma.PunchEventScalarWhereInput[]
  NOT?: Prisma.PunchEventScalarWhereInput | Prisma.PunchEventScalarWhereInput[]
  id?: Prisma.StringFilter<"PunchEvent"> | string
  tenantId?: Prisma.StringFilter<"PunchEvent"> | string
  employeeId?: Prisma.StringFilter<"PunchEvent"> | string
  occurredAt?: Prisma.DateTimeFilter<"PunchEvent"> | Date | string
  kind?: Prisma.EnumPunchKindFilter<"PunchEvent"> | $Enums.PunchKind
  source?: Prisma.EnumPunchSourceFilter<"PunchEvent"> | $Enums.PunchSource
  deviceId?: Prisma.StringNullableFilter<"PunchEvent"> | string | null
  rawPayload?: Prisma.JsonNullableFilter<"PunchEvent">
  integrityHash?: Prisma.StringNullableFilter<"PunchEvent"> | string | null
  createdAt?: Prisma.DateTimeFilter<"PunchEvent"> | Date | string
}

export type PunchEventCreateWithoutEmployeeInput = {
  id?: string
  occurredAt: Date | string
  kind: $Enums.PunchKind
  source: $Enums.PunchSource
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: string | null
  createdAt?: Date | string
  tenant: Prisma.TenantCreateNestedOneWithoutPunchEventsInput
  device?: Prisma.BiometricDeviceCreateNestedOneWithoutPunchesInput
}

export type PunchEventUncheckedCreateWithoutEmployeeInput = {
  id?: string
  tenantId: string
  occurredAt: Date | string
  kind: $Enums.PunchKind
  source: $Enums.PunchSource
  deviceId?: string | null
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: string | null
  createdAt?: Date | string
}

export type PunchEventCreateOrConnectWithoutEmployeeInput = {
  where: Prisma.PunchEventWhereUniqueInput
  create: Prisma.XOR<Prisma.PunchEventCreateWithoutEmployeeInput, Prisma.PunchEventUncheckedCreateWithoutEmployeeInput>
}

export type PunchEventCreateManyEmployeeInputEnvelope = {
  data: Prisma.PunchEventCreateManyEmployeeInput | Prisma.PunchEventCreateManyEmployeeInput[]
  skipDuplicates?: boolean
}

export type PunchEventUpsertWithWhereUniqueWithoutEmployeeInput = {
  where: Prisma.PunchEventWhereUniqueInput
  update: Prisma.XOR<Prisma.PunchEventUpdateWithoutEmployeeInput, Prisma.PunchEventUncheckedUpdateWithoutEmployeeInput>
  create: Prisma.XOR<Prisma.PunchEventCreateWithoutEmployeeInput, Prisma.PunchEventUncheckedCreateWithoutEmployeeInput>
}

export type PunchEventUpdateWithWhereUniqueWithoutEmployeeInput = {
  where: Prisma.PunchEventWhereUniqueInput
  data: Prisma.XOR<Prisma.PunchEventUpdateWithoutEmployeeInput, Prisma.PunchEventUncheckedUpdateWithoutEmployeeInput>
}

export type PunchEventUpdateManyWithWhereWithoutEmployeeInput = {
  where: Prisma.PunchEventScalarWhereInput
  data: Prisma.XOR<Prisma.PunchEventUpdateManyMutationInput, Prisma.PunchEventUncheckedUpdateManyWithoutEmployeeInput>
}

export type PunchEventCreateWithoutDeviceInput = {
  id?: string
  occurredAt: Date | string
  kind: $Enums.PunchKind
  source: $Enums.PunchSource
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: string | null
  createdAt?: Date | string
  tenant: Prisma.TenantCreateNestedOneWithoutPunchEventsInput
  employee: Prisma.EmployeeCreateNestedOneWithoutPunchesInput
}

export type PunchEventUncheckedCreateWithoutDeviceInput = {
  id?: string
  tenantId: string
  employeeId: string
  occurredAt: Date | string
  kind: $Enums.PunchKind
  source: $Enums.PunchSource
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: string | null
  createdAt?: Date | string
}

export type PunchEventCreateOrConnectWithoutDeviceInput = {
  where: Prisma.PunchEventWhereUniqueInput
  create: Prisma.XOR<Prisma.PunchEventCreateWithoutDeviceInput, Prisma.PunchEventUncheckedCreateWithoutDeviceInput>
}

export type PunchEventCreateManyDeviceInputEnvelope = {
  data: Prisma.PunchEventCreateManyDeviceInput | Prisma.PunchEventCreateManyDeviceInput[]
  skipDuplicates?: boolean
}

export type PunchEventUpsertWithWhereUniqueWithoutDeviceInput = {
  where: Prisma.PunchEventWhereUniqueInput
  update: Prisma.XOR<Prisma.PunchEventUpdateWithoutDeviceInput, Prisma.PunchEventUncheckedUpdateWithoutDeviceInput>
  create: Prisma.XOR<Prisma.PunchEventCreateWithoutDeviceInput, Prisma.PunchEventUncheckedCreateWithoutDeviceInput>
}

export type PunchEventUpdateWithWhereUniqueWithoutDeviceInput = {
  where: Prisma.PunchEventWhereUniqueInput
  data: Prisma.XOR<Prisma.PunchEventUpdateWithoutDeviceInput, Prisma.PunchEventUncheckedUpdateWithoutDeviceInput>
}

export type PunchEventUpdateManyWithWhereWithoutDeviceInput = {
  where: Prisma.PunchEventScalarWhereInput
  data: Prisma.XOR<Prisma.PunchEventUpdateManyMutationInput, Prisma.PunchEventUncheckedUpdateManyWithoutDeviceInput>
}

export type PunchEventCreateManyTenantInput = {
  id?: string
  employeeId: string
  occurredAt: Date | string
  kind: $Enums.PunchKind
  source: $Enums.PunchSource
  deviceId?: string | null
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: string | null
  createdAt?: Date | string
}

export type PunchEventUpdateWithoutTenantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  occurredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  kind?: Prisma.EnumPunchKindFieldUpdateOperationsInput | $Enums.PunchKind
  source?: Prisma.EnumPunchSourceFieldUpdateOperationsInput | $Enums.PunchSource
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  employee?: Prisma.EmployeeUpdateOneRequiredWithoutPunchesNestedInput
  device?: Prisma.BiometricDeviceUpdateOneWithoutPunchesNestedInput
}

export type PunchEventUncheckedUpdateWithoutTenantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  employeeId?: Prisma.StringFieldUpdateOperationsInput | string
  occurredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  kind?: Prisma.EnumPunchKindFieldUpdateOperationsInput | $Enums.PunchKind
  source?: Prisma.EnumPunchSourceFieldUpdateOperationsInput | $Enums.PunchSource
  deviceId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PunchEventUncheckedUpdateManyWithoutTenantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  employeeId?: Prisma.StringFieldUpdateOperationsInput | string
  occurredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  kind?: Prisma.EnumPunchKindFieldUpdateOperationsInput | $Enums.PunchKind
  source?: Prisma.EnumPunchSourceFieldUpdateOperationsInput | $Enums.PunchSource
  deviceId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PunchEventCreateManyEmployeeInput = {
  id?: string
  tenantId: string
  occurredAt: Date | string
  kind: $Enums.PunchKind
  source: $Enums.PunchSource
  deviceId?: string | null
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: string | null
  createdAt?: Date | string
}

export type PunchEventUpdateWithoutEmployeeInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  occurredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  kind?: Prisma.EnumPunchKindFieldUpdateOperationsInput | $Enums.PunchKind
  source?: Prisma.EnumPunchSourceFieldUpdateOperationsInput | $Enums.PunchSource
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  tenant?: Prisma.TenantUpdateOneRequiredWithoutPunchEventsNestedInput
  device?: Prisma.BiometricDeviceUpdateOneWithoutPunchesNestedInput
}

export type PunchEventUncheckedUpdateWithoutEmployeeInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  occurredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  kind?: Prisma.EnumPunchKindFieldUpdateOperationsInput | $Enums.PunchKind
  source?: Prisma.EnumPunchSourceFieldUpdateOperationsInput | $Enums.PunchSource
  deviceId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PunchEventUncheckedUpdateManyWithoutEmployeeInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  occurredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  kind?: Prisma.EnumPunchKindFieldUpdateOperationsInput | $Enums.PunchKind
  source?: Prisma.EnumPunchSourceFieldUpdateOperationsInput | $Enums.PunchSource
  deviceId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PunchEventCreateManyDeviceInput = {
  id?: string
  tenantId: string
  employeeId: string
  occurredAt: Date | string
  kind: $Enums.PunchKind
  source: $Enums.PunchSource
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: string | null
  createdAt?: Date | string
}

export type PunchEventUpdateWithoutDeviceInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  occurredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  kind?: Prisma.EnumPunchKindFieldUpdateOperationsInput | $Enums.PunchKind
  source?: Prisma.EnumPunchSourceFieldUpdateOperationsInput | $Enums.PunchSource
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  tenant?: Prisma.TenantUpdateOneRequiredWithoutPunchEventsNestedInput
  employee?: Prisma.EmployeeUpdateOneRequiredWithoutPunchesNestedInput
}

export type PunchEventUncheckedUpdateWithoutDeviceInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  employeeId?: Prisma.StringFieldUpdateOperationsInput | string
  occurredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  kind?: Prisma.EnumPunchKindFieldUpdateOperationsInput | $Enums.PunchKind
  source?: Prisma.EnumPunchSourceFieldUpdateOperationsInput | $Enums.PunchSource
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PunchEventUncheckedUpdateManyWithoutDeviceInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  employeeId?: Prisma.StringFieldUpdateOperationsInput | string
  occurredAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  kind?: Prisma.EnumPunchKindFieldUpdateOperationsInput | $Enums.PunchKind
  source?: Prisma.EnumPunchSourceFieldUpdateOperationsInput | $Enums.PunchSource
  rawPayload?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue
  integrityHash?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type PunchEventSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  tenantId?: boolean
  employeeId?: boolean
  occurredAt?: boolean
  kind?: boolean
  source?: boolean
  deviceId?: boolean
  rawPayload?: boolean
  integrityHash?: boolean
  createdAt?: boolean
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
  employee?: boolean | Prisma.EmployeeDefaultArgs<ExtArgs>
  device?: boolean | Prisma.PunchEvent$deviceArgs<ExtArgs>
}, ExtArgs["result"]["punchEvent"]>

export type PunchEventSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  tenantId?: boolean
  employeeId?: boolean
  occurredAt?: boolean
  kind?: boolean
  source?: boolean
  deviceId?: boolean
  rawPayload?: boolean
  integrityHash?: boolean
  createdAt?: boolean
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
  employee?: boolean | Prisma.EmployeeDefaultArgs<ExtArgs>
  device?: boolean | Prisma.PunchEvent$deviceArgs<ExtArgs>
}, ExtArgs["result"]["punchEvent"]>

export type PunchEventSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  tenantId?: boolean
  employeeId?: boolean
  occurredAt?: boolean
  kind?: boolean
  source?: boolean
  deviceId?: boolean
  rawPayload?: boolean
  integrityHash?: boolean
  createdAt?: boolean
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
  employee?: boolean | Prisma.EmployeeDefaultArgs<ExtArgs>
  device?: boolean | Prisma.PunchEvent$deviceArgs<ExtArgs>
}, ExtArgs["result"]["punchEvent"]>

export type PunchEventSelectScalar = {
  id?: boolean
  tenantId?: boolean
  employeeId?: boolean
  occurredAt?: boolean
  kind?: boolean
  source?: boolean
  deviceId?: boolean
  rawPayload?: boolean
  integrityHash?: boolean
  createdAt?: boolean
}

export type PunchEventOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "tenantId" | "employeeId" | "occurredAt" | "kind" | "source" | "deviceId" | "rawPayload" | "integrityHash" | "createdAt", ExtArgs["result"]["punchEvent"]>
export type PunchEventInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
  employee?: boolean | Prisma.EmployeeDefaultArgs<ExtArgs>
  device?: boolean | Prisma.PunchEvent$deviceArgs<ExtArgs>
}
export type PunchEventIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
  employee?: boolean | Prisma.EmployeeDefaultArgs<ExtArgs>
  device?: boolean | Prisma.PunchEvent$deviceArgs<ExtArgs>
}
export type PunchEventIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
  employee?: boolean | Prisma.EmployeeDefaultArgs<ExtArgs>
  device?: boolean | Prisma.PunchEvent$deviceArgs<ExtArgs>
}

export type $PunchEventPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "PunchEvent"
  objects: {
    tenant: Prisma.$TenantPayload<ExtArgs>
    employee: Prisma.$EmployeePayload<ExtArgs>
    device: Prisma.$BiometricDevicePayload<ExtArgs> | null
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    tenantId: string
    employeeId: string
    occurredAt: Date
    kind: $Enums.PunchKind
    source: $Enums.PunchSource
    deviceId: string | null
    rawPayload: runtime.JsonValue | null
    integrityHash: string | null
    createdAt: Date
  }, ExtArgs["result"]["punchEvent"]>
  composites: {}
}

export type PunchEventGetPayload<S extends boolean | null | undefined | PunchEventDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$PunchEventPayload, S>

export type PunchEventCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<PunchEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PunchEventCountAggregateInputType | true
  }

export interface PunchEventDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PunchEvent'], meta: { name: 'PunchEvent' } }
  /**
   * Find zero or one PunchEvent that matches the filter.
   * @param {PunchEventFindUniqueArgs} args - Arguments to find a PunchEvent
   * @example
   * // Get one PunchEvent
   * const punchEvent = await prisma.punchEvent.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends PunchEventFindUniqueArgs>(args: Prisma.SelectSubset<T, PunchEventFindUniqueArgs<ExtArgs>>): Prisma.Prisma__PunchEventClient<runtime.Types.Result.GetResult<Prisma.$PunchEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one PunchEvent that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {PunchEventFindUniqueOrThrowArgs} args - Arguments to find a PunchEvent
   * @example
   * // Get one PunchEvent
   * const punchEvent = await prisma.punchEvent.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends PunchEventFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, PunchEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__PunchEventClient<runtime.Types.Result.GetResult<Prisma.$PunchEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first PunchEvent that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PunchEventFindFirstArgs} args - Arguments to find a PunchEvent
   * @example
   * // Get one PunchEvent
   * const punchEvent = await prisma.punchEvent.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends PunchEventFindFirstArgs>(args?: Prisma.SelectSubset<T, PunchEventFindFirstArgs<ExtArgs>>): Prisma.Prisma__PunchEventClient<runtime.Types.Result.GetResult<Prisma.$PunchEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first PunchEvent that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PunchEventFindFirstOrThrowArgs} args - Arguments to find a PunchEvent
   * @example
   * // Get one PunchEvent
   * const punchEvent = await prisma.punchEvent.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends PunchEventFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, PunchEventFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__PunchEventClient<runtime.Types.Result.GetResult<Prisma.$PunchEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more PunchEvents that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PunchEventFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all PunchEvents
   * const punchEvents = await prisma.punchEvent.findMany()
   * 
   * // Get first 10 PunchEvents
   * const punchEvents = await prisma.punchEvent.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const punchEventWithIdOnly = await prisma.punchEvent.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends PunchEventFindManyArgs>(args?: Prisma.SelectSubset<T, PunchEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PunchEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a PunchEvent.
   * @param {PunchEventCreateArgs} args - Arguments to create a PunchEvent.
   * @example
   * // Create one PunchEvent
   * const PunchEvent = await prisma.punchEvent.create({
   *   data: {
   *     // ... data to create a PunchEvent
   *   }
   * })
   * 
   */
  create<T extends PunchEventCreateArgs>(args: Prisma.SelectSubset<T, PunchEventCreateArgs<ExtArgs>>): Prisma.Prisma__PunchEventClient<runtime.Types.Result.GetResult<Prisma.$PunchEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many PunchEvents.
   * @param {PunchEventCreateManyArgs} args - Arguments to create many PunchEvents.
   * @example
   * // Create many PunchEvents
   * const punchEvent = await prisma.punchEvent.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends PunchEventCreateManyArgs>(args?: Prisma.SelectSubset<T, PunchEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many PunchEvents and returns the data saved in the database.
   * @param {PunchEventCreateManyAndReturnArgs} args - Arguments to create many PunchEvents.
   * @example
   * // Create many PunchEvents
   * const punchEvent = await prisma.punchEvent.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many PunchEvents and only return the `id`
   * const punchEventWithIdOnly = await prisma.punchEvent.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends PunchEventCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, PunchEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PunchEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a PunchEvent.
   * @param {PunchEventDeleteArgs} args - Arguments to delete one PunchEvent.
   * @example
   * // Delete one PunchEvent
   * const PunchEvent = await prisma.punchEvent.delete({
   *   where: {
   *     // ... filter to delete one PunchEvent
   *   }
   * })
   * 
   */
  delete<T extends PunchEventDeleteArgs>(args: Prisma.SelectSubset<T, PunchEventDeleteArgs<ExtArgs>>): Prisma.Prisma__PunchEventClient<runtime.Types.Result.GetResult<Prisma.$PunchEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one PunchEvent.
   * @param {PunchEventUpdateArgs} args - Arguments to update one PunchEvent.
   * @example
   * // Update one PunchEvent
   * const punchEvent = await prisma.punchEvent.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends PunchEventUpdateArgs>(args: Prisma.SelectSubset<T, PunchEventUpdateArgs<ExtArgs>>): Prisma.Prisma__PunchEventClient<runtime.Types.Result.GetResult<Prisma.$PunchEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more PunchEvents.
   * @param {PunchEventDeleteManyArgs} args - Arguments to filter PunchEvents to delete.
   * @example
   * // Delete a few PunchEvents
   * const { count } = await prisma.punchEvent.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends PunchEventDeleteManyArgs>(args?: Prisma.SelectSubset<T, PunchEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more PunchEvents.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PunchEventUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many PunchEvents
   * const punchEvent = await prisma.punchEvent.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends PunchEventUpdateManyArgs>(args: Prisma.SelectSubset<T, PunchEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more PunchEvents and returns the data updated in the database.
   * @param {PunchEventUpdateManyAndReturnArgs} args - Arguments to update many PunchEvents.
   * @example
   * // Update many PunchEvents
   * const punchEvent = await prisma.punchEvent.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more PunchEvents and only return the `id`
   * const punchEventWithIdOnly = await prisma.punchEvent.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends PunchEventUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, PunchEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PunchEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one PunchEvent.
   * @param {PunchEventUpsertArgs} args - Arguments to update or create a PunchEvent.
   * @example
   * // Update or create a PunchEvent
   * const punchEvent = await prisma.punchEvent.upsert({
   *   create: {
   *     // ... data to create a PunchEvent
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the PunchEvent we want to update
   *   }
   * })
   */
  upsert<T extends PunchEventUpsertArgs>(args: Prisma.SelectSubset<T, PunchEventUpsertArgs<ExtArgs>>): Prisma.Prisma__PunchEventClient<runtime.Types.Result.GetResult<Prisma.$PunchEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of PunchEvents.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PunchEventCountArgs} args - Arguments to filter PunchEvents to count.
   * @example
   * // Count the number of PunchEvents
   * const count = await prisma.punchEvent.count({
   *   where: {
   *     // ... the filter for the PunchEvents we want to count
   *   }
   * })
  **/
  count<T extends PunchEventCountArgs>(
    args?: Prisma.Subset<T, PunchEventCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], PunchEventCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a PunchEvent.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PunchEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends PunchEventAggregateArgs>(args: Prisma.Subset<T, PunchEventAggregateArgs>): Prisma.PrismaPromise<GetPunchEventAggregateType<T>>

  /**
   * Group by PunchEvent.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PunchEventGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends PunchEventGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: PunchEventGroupByArgs['orderBy'] }
      : { orderBy?: PunchEventGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, PunchEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPunchEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the PunchEvent model
 */
readonly fields: PunchEventFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for PunchEvent.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__PunchEventClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  tenant<T extends Prisma.TenantDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.TenantDefaultArgs<ExtArgs>>): Prisma.Prisma__TenantClient<runtime.Types.Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  employee<T extends Prisma.EmployeeDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.EmployeeDefaultArgs<ExtArgs>>): Prisma.Prisma__EmployeeClient<runtime.Types.Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  device<T extends Prisma.PunchEvent$deviceArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.PunchEvent$deviceArgs<ExtArgs>>): Prisma.Prisma__BiometricDeviceClient<runtime.Types.Result.GetResult<Prisma.$BiometricDevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the PunchEvent model
 */
export interface PunchEventFieldRefs {
  readonly id: Prisma.FieldRef<"PunchEvent", 'String'>
  readonly tenantId: Prisma.FieldRef<"PunchEvent", 'String'>
  readonly employeeId: Prisma.FieldRef<"PunchEvent", 'String'>
  readonly occurredAt: Prisma.FieldRef<"PunchEvent", 'DateTime'>
  readonly kind: Prisma.FieldRef<"PunchEvent", 'PunchKind'>
  readonly source: Prisma.FieldRef<"PunchEvent", 'PunchSource'>
  readonly deviceId: Prisma.FieldRef<"PunchEvent", 'String'>
  readonly rawPayload: Prisma.FieldRef<"PunchEvent", 'Json'>
  readonly integrityHash: Prisma.FieldRef<"PunchEvent", 'String'>
  readonly createdAt: Prisma.FieldRef<"PunchEvent", 'DateTime'>
}
    

// Custom InputTypes
/**
 * PunchEvent findUnique
 */
export type PunchEventFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PunchEvent
   */
  select?: Prisma.PunchEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PunchEvent
   */
  omit?: Prisma.PunchEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PunchEventInclude<ExtArgs> | null
  /**
   * Filter, which PunchEvent to fetch.
   */
  where: Prisma.PunchEventWhereUniqueInput
}

/**
 * PunchEvent findUniqueOrThrow
 */
export type PunchEventFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PunchEvent
   */
  select?: Prisma.PunchEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PunchEvent
   */
  omit?: Prisma.PunchEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PunchEventInclude<ExtArgs> | null
  /**
   * Filter, which PunchEvent to fetch.
   */
  where: Prisma.PunchEventWhereUniqueInput
}

/**
 * PunchEvent findFirst
 */
export type PunchEventFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PunchEvent
   */
  select?: Prisma.PunchEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PunchEvent
   */
  omit?: Prisma.PunchEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PunchEventInclude<ExtArgs> | null
  /**
   * Filter, which PunchEvent to fetch.
   */
  where?: Prisma.PunchEventWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PunchEvents to fetch.
   */
  orderBy?: Prisma.PunchEventOrderByWithRelationInput | Prisma.PunchEventOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for PunchEvents.
   */
  cursor?: Prisma.PunchEventWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PunchEvents from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PunchEvents.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of PunchEvents.
   */
  distinct?: Prisma.PunchEventScalarFieldEnum | Prisma.PunchEventScalarFieldEnum[]
}

/**
 * PunchEvent findFirstOrThrow
 */
export type PunchEventFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PunchEvent
   */
  select?: Prisma.PunchEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PunchEvent
   */
  omit?: Prisma.PunchEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PunchEventInclude<ExtArgs> | null
  /**
   * Filter, which PunchEvent to fetch.
   */
  where?: Prisma.PunchEventWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PunchEvents to fetch.
   */
  orderBy?: Prisma.PunchEventOrderByWithRelationInput | Prisma.PunchEventOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for PunchEvents.
   */
  cursor?: Prisma.PunchEventWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PunchEvents from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PunchEvents.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of PunchEvents.
   */
  distinct?: Prisma.PunchEventScalarFieldEnum | Prisma.PunchEventScalarFieldEnum[]
}

/**
 * PunchEvent findMany
 */
export type PunchEventFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PunchEvent
   */
  select?: Prisma.PunchEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PunchEvent
   */
  omit?: Prisma.PunchEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PunchEventInclude<ExtArgs> | null
  /**
   * Filter, which PunchEvents to fetch.
   */
  where?: Prisma.PunchEventWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of PunchEvents to fetch.
   */
  orderBy?: Prisma.PunchEventOrderByWithRelationInput | Prisma.PunchEventOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing PunchEvents.
   */
  cursor?: Prisma.PunchEventWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` PunchEvents from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` PunchEvents.
   */
  skip?: number
  distinct?: Prisma.PunchEventScalarFieldEnum | Prisma.PunchEventScalarFieldEnum[]
}

/**
 * PunchEvent create
 */
export type PunchEventCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PunchEvent
   */
  select?: Prisma.PunchEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PunchEvent
   */
  omit?: Prisma.PunchEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PunchEventInclude<ExtArgs> | null
  /**
   * The data needed to create a PunchEvent.
   */
  data: Prisma.XOR<Prisma.PunchEventCreateInput, Prisma.PunchEventUncheckedCreateInput>
}

/**
 * PunchEvent createMany
 */
export type PunchEventCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many PunchEvents.
   */
  data: Prisma.PunchEventCreateManyInput | Prisma.PunchEventCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * PunchEvent createManyAndReturn
 */
export type PunchEventCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PunchEvent
   */
  select?: Prisma.PunchEventSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the PunchEvent
   */
  omit?: Prisma.PunchEventOmit<ExtArgs> | null
  /**
   * The data used to create many PunchEvents.
   */
  data: Prisma.PunchEventCreateManyInput | Prisma.PunchEventCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PunchEventIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * PunchEvent update
 */
export type PunchEventUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PunchEvent
   */
  select?: Prisma.PunchEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PunchEvent
   */
  omit?: Prisma.PunchEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PunchEventInclude<ExtArgs> | null
  /**
   * The data needed to update a PunchEvent.
   */
  data: Prisma.XOR<Prisma.PunchEventUpdateInput, Prisma.PunchEventUncheckedUpdateInput>
  /**
   * Choose, which PunchEvent to update.
   */
  where: Prisma.PunchEventWhereUniqueInput
}

/**
 * PunchEvent updateMany
 */
export type PunchEventUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update PunchEvents.
   */
  data: Prisma.XOR<Prisma.PunchEventUpdateManyMutationInput, Prisma.PunchEventUncheckedUpdateManyInput>
  /**
   * Filter which PunchEvents to update
   */
  where?: Prisma.PunchEventWhereInput
  /**
   * Limit how many PunchEvents to update.
   */
  limit?: number
}

/**
 * PunchEvent updateManyAndReturn
 */
export type PunchEventUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PunchEvent
   */
  select?: Prisma.PunchEventSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the PunchEvent
   */
  omit?: Prisma.PunchEventOmit<ExtArgs> | null
  /**
   * The data used to update PunchEvents.
   */
  data: Prisma.XOR<Prisma.PunchEventUpdateManyMutationInput, Prisma.PunchEventUncheckedUpdateManyInput>
  /**
   * Filter which PunchEvents to update
   */
  where?: Prisma.PunchEventWhereInput
  /**
   * Limit how many PunchEvents to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PunchEventIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * PunchEvent upsert
 */
export type PunchEventUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PunchEvent
   */
  select?: Prisma.PunchEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PunchEvent
   */
  omit?: Prisma.PunchEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PunchEventInclude<ExtArgs> | null
  /**
   * The filter to search for the PunchEvent to update in case it exists.
   */
  where: Prisma.PunchEventWhereUniqueInput
  /**
   * In case the PunchEvent found by the `where` argument doesn't exist, create a new PunchEvent with this data.
   */
  create: Prisma.XOR<Prisma.PunchEventCreateInput, Prisma.PunchEventUncheckedCreateInput>
  /**
   * In case the PunchEvent was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.PunchEventUpdateInput, Prisma.PunchEventUncheckedUpdateInput>
}

/**
 * PunchEvent delete
 */
export type PunchEventDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PunchEvent
   */
  select?: Prisma.PunchEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PunchEvent
   */
  omit?: Prisma.PunchEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PunchEventInclude<ExtArgs> | null
  /**
   * Filter which PunchEvent to delete.
   */
  where: Prisma.PunchEventWhereUniqueInput
}

/**
 * PunchEvent deleteMany
 */
export type PunchEventDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which PunchEvents to delete
   */
  where?: Prisma.PunchEventWhereInput
  /**
   * Limit how many PunchEvents to delete.
   */
  limit?: number
}

/**
 * PunchEvent.device
 */
export type PunchEvent$deviceArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the BiometricDevice
   */
  select?: Prisma.BiometricDeviceSelect<ExtArgs> | null
  /**
   * Omit specific fields from the BiometricDevice
   */
  omit?: Prisma.BiometricDeviceOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.BiometricDeviceInclude<ExtArgs> | null
  where?: Prisma.BiometricDeviceWhereInput
}

/**
 * PunchEvent without action
 */
export type PunchEventDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PunchEvent
   */
  select?: Prisma.PunchEventSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PunchEvent
   */
  omit?: Prisma.PunchEventOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PunchEventInclude<ExtArgs> | null
}
